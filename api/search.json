[{"id":"af912e0d33a827f03582ef107fe8a87d","title":"SpringBoot","content":"[toc]\nSpring boot 2一、Boot入门SpringBoot2核心技术与响应式编程: https://www.yuque.com/atguigu/springboot\n1、简介\n简化Spring应用开发的一个框架；\n整个Spring技术栈的一大整合；\nJ2EE开发的一站式解决方案；\n\nSpring Boot来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用\n背景:\nJ2EE笨重的开发、繁多的配置、低下的开发效率、复杂的部署流程、第三方技术集成难度大。\n解决∶\n“Spring全家桶”时代。Spring Boot &gt;J2EE一站式解决方案Spring Cloud→分布式整体解决方案\nUser -&gt; Spring Boot -&gt; Spring\n优点\n\n快速创建独立运行的Spring项目以及主流框架集成\n使用嵌入式的Servlet容器，应用无需打成WAR包\nstarters自动依赖与版本控制\n大量的自动配置，简化开发，也可修改默认值\n无需配置XML，无代码生成，开箱即用\n准生产环境的运行时应用监控\n与云计算的天然集成\n\n2、微服务2014， martin fowler\n微服务：架构风格（服务微化）\n一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；\n单体应用：ALL IN ONE微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；\n3、环境配置\njdk 1.8.0_40 \nSpring boot 2.4.3\nIDEA 2020.3\nMaven 3.6.3\n给Maven的settigs.xml文件中的 里加上如下配置\n\n&lt;profile>\n  &lt;id>jdk-1.8&lt;/id>\n  &lt;activation>\n    &lt;activeByDefault>true&lt;/activeByDefault>\n    &lt;jdk>1.8&lt;/jdk>\n  &lt;/activation>\n  &lt;properties>\n    &lt;maven.compiler.source>1.8&lt;/maven.compiler.source>\n    &lt;maven.compiler.target>1.8&lt;/maven.compiler.target>\n    &lt;maven.compiler.compilerVersion>1.8&lt;/maven.compiler.compilerVersion>\n  &lt;/properties>\n&lt;/profile>\n4、Spring Boot HelloWorld功能：浏览器发送hello请求，服务器请求并处理，响应HelloWorld字符串\n4.1 初始化项目根据该网址创建项目：https://blog.51cto.com/yaowusheng/2565318\n不能使用RequestMapping等，在pom文件中添加如下 \n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n&lt;/dependency>\n\n\n4.2 编写相关的Controller、Service(注意，contrller类所在包的级别，要在主程序类下。否则找不到)\npackage com.example.springbootdemo.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class HelloWorldController &#123;\n    @ResponseBody\n    @RequestMapping(\"/hello\")\n    public String helloWorld() &#123;\n        return \"hello\";\n    &#125;\n&#125;\n\n4.3 打包成可执行的jar包 IDEA操作步骤\n在IDEA右侧，选择Maven–&gt;展开自己的项目–》选择Lifecycle–》双击package–&gt;运行完成之后，在左边项目目录中展开target–&gt;里面有个jar包，可以使用java -jar运行该jar包。\n&lt;!--    这个插件，可以应用打包成一个可执行的jar包-->\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.springframework.boot&lt;/groupId>\n                &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n5、探究Hello World5.1 POM文件5.1.1 父项目    &lt;parent>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-parent&lt;/artifactId>\n        &lt;version>2.4.3&lt;/version>\n        &lt;relativePath/> &lt;!-- lookup parent from repository -->\n    &lt;/parent>\n    \n    他的父项目是\n    &lt;parent>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-dependencies&lt;/artifactId>\n        &lt;version>2.4.3&lt;/version>\n    &lt;/parent>\n他来真正管理Spring Boot应用里面的所有依赖版本；\n\nSpring Boot的版本仲裁中心；\n以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）\n5.1.2 启动器&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n&lt;/dependency>\n\nSpring-boot-starter-web:\n​    Spring-boot-starter:spring-boot 场景控制器：帮我们导入了web模块正常运行所依赖的组件 ；\nSpring Boot将所有的功能场景都抽取出来 ，做成一个个的starters（启动器），只需要在项目里面引入 这些starter相关场景的所有依赖都会导入进行。要用什么功能就导入什么场景的启动器\n5.2 主程序类，主入口类import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n/**\n@SpringBootApplication来标注一个主程序类，说明这是一个Spring Boot应用\n*/\n@SpringBootApplication\npublic class SpringbootdemoApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SpringbootdemoApplication.class, args);\n    &#125;\n\n&#125;\n  \n\n@SpringBootApplication : Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = &#123;@Filter(\n    type = FilterType.CUSTOM,\n    classes = &#123;TypeExcludeFilter.class&#125;\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = &#123;AutoConfigurationExcludeFilter.class&#125;\n)&#125;\n)\n\n@SpringBootConfiguration : Spring Boot的配置类    标注在某个类上，表示是一个Spring Boot的配置类；\n​    @Configuration:配置类上来标注这个注解；\n​        配置类——配置文件；配置类也是容器中的一个组件；@Component\n@EnableAutoConfiguration:开启自动配置功能；\n​    以前我们需要配置的东西，Spring Boot帮我们自动配置；**@EnableAutoConfiguration**告诉Spring Boot开启自动配置功能；这样自动配置才能生效；\n@AutoConfigurationPackage\n@Import(&#123;AutoConfigurationImportSelector.class&#125;)\npublic @interface EnableAutoConfiguration &#123;\n\n@AutoConfigurationPackage: 自动配置包\n​    @Import({AutoConfigurationImportSelector.class})；\n​    Spring的底层注解@import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；\n将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；\n​    @Import(AutoConfigurationImportSelector.class) ;\n​        给容器中导入组件？\n​        EnableAutoConfiguratioImportSelector： 导入哪些组件的选择器；\n​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；\n​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）;就是给容器中导入这个场景所需要的所有组件，并配置好这些组件；\n有了自动配置类，免去了我们手动编写配置注入功能组件等工作；\n​        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, classLoader);\nSpring Boot启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 ,将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；\nJ2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-2.4.3.jar;\n6、使用Spring Initializer快速创建Spring Boot项目根据该网址创建项目：https://blog.51cto.com/yaowusheng/2565318\nIDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；\n选择我们需要的模块；向导会联网创建Spring Boot项目；\n默认生成的Spring Boot项目；\n\n主程序 已经写好，只需要写我们的逻辑\nresources文件夹中目录结构\nstatic :保存所有的静态资源：js css images；\ntemplates:保存所有的模板页面：（Spring Boot默认jar包使用嵌入式的Tomcat,默认不支持JSP页面）‘可以使用模板引擎（freemarker、thymeleaf）；\napplication.properties: Spring Boot应用的配置文件；可以修改一些默认设置；\n\n\n\n二、Spring Boot配置2.1 配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的;\n如果同时配置，properties优先yml\n\napplication.properties\n\napplication.yml\n配置文件的作用: 修改SpringBoot自动配置的默认值;\nSpringBoot在底层都给我们自动配置好;\n\n\nYAML（YAML Ain`t Markup Language）\n+ YAML A Markup Language：是一个标记语言\n+ YAML isn`t Markup Language：不是一个标记语言\n\n标记语言：\n+ 以前的配置文件：大多都使用的是xxx.xml文件；\n+ YAML:以数据为中心，比json、xml更适合做配置文件；\n+ YAML:配置例子\n\nserver:\n\tport: 8080\n\n+ XML:\n\n&lt;server>\n\t&lt;port>8080&lt;/port>\n&lt;/server>\n\n2.2、YAML语法2.2.1 基本语法k:(空格)v:表示一对键值对（空格必须有);以空格的缩进来控制层级关系;只要是左对齐的一列数据，都是同一个层级的\nserver:\n\tport: 8081\n\tpath: /hello\n\n属性和值也是大小写敏感;\n2.2.2 值的写法字面量︰普通的值（数字，字符串，布尔)​    k: v: 字面直接来写;​        字符串默认不用加上单引号或者双引号;\n​            “” 双引号：不会转义字符串里面的特殊字符;特殊字符会作为本身想表示的意思\n​                name: “zhangsan \\n lisi    输出: zhangsan 换行 lisi\n​            ’:单引号:会转义特殊字符，特殊字符最终只是一个普通的字符串数据​                name: “zhangsan \\n lisi    输出: zhangsan in lisi\n2.2.3 对象、Map（属性和值）（键值对）：​    k: v :在下一行来写对象的属性和值的关系； 注意缩进\n​        对象还是k: v的方式\nserver:\n\tport: 8081\n\n行内写法：\nserver: (port: 8081, path: &#x2F;test)\n\n数组（List、Set）:用 - 值表示数组中的一个元素\npets:\n- cat\n- dog\n- pig\n\n行内写法\npets: [cat, dog, pig]\n\n2.3 配置文件值注入2.3.1 配置文件 xx.yamlperson:\n  name: xiaozhu\n  isDog: true\n  age: 18\n  data: 2020/12/1\n  map: &#123;k1: yihao, k2: erhao&#125;\n  list:\n    - qqq\n    - aaa\n    - ccc\n  dog:\n    name: jingmao\n    remarks: ni shi jing mao \n\njavaBean:\n/*\n* 将配置文件中配置的每一个属性值，映射到这个组件中\n* @ConfigurationProperties : 告诉Spring Boot将本类中的所有属性和配置文件中相关的配置进行绑定；\n* prefix = \"person\" ，配置文件中哪个下面的所有属性一一映射*/\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person &#123;\n    String name;\n    boolean isDog;\n    Integer age;\n    Date data;\n    Map&lt;String, Object> map;\n    List&lt;Object> list;\n    Dog dog;\n\n导入配置文件处理器，编写配置就会有提示\n&lt;!--   导入配置文件处理器，配置文件进行绑定就会有提示     -->\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-configuration-processor&lt;/artifactId>\n    &lt;optional>true&lt;/optional>\n&lt;/dependency>\n\n2.3.2使用properties，其他配置相同，properties文件如下person.name=张三\nperson.age=19\nperson.list=a,b,c\nperson.map.k1=aaa\nperson.map.k2=bbb\nperson.dog.name=xiaoha\nperson.dog.remarks=nihao\n# 如果遇到中文编码问题，在settings-->file Encodings--> Properties Files --> 选择UTF-8加上勾选Transparent native-to-ascii conversion\n\n\n2.3.3 @Value获取值和@ConfigurationProperties获取值比较\n\n\n\n@ConfiggurationProperties\n@Value\n\n\n\n功能\n批量注入配置文件中的属性\n一个个指定\n\n\n松散绑定（松散语法）\n支持\n不支持\n\n\nSpEL\n不支持\n支持\n\n\nJSR303数据校验\n支持\n不支持\n\n\n复杂类型封装\n支持\n不支持\n\n\n配置文件yml还是properties他们都能获取到值；\n如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties;\n2.3.4 @PropertySource&amp; @ImportResource@PropertySOurce加载指定的配置文件；\n/*\n* 将配置文件中配置的每一个属性值，映射到这个组件中\n* @ConfigurationProperties : 告诉Spring Boot将本类中的所有属性和配置文件中相关的配置进行绑定；默认全局文件获取值\n* prefix = \"person\" ，配置文件中哪个下面的所有属性一一映射*/\n@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person &#123;\n    String name;\n    boolean isDog;\n    Integer age;\n    Date data;\n    Map&lt;String, Object> map;\n    List&lt;Object> list;\n    Dog dog;\n\n@ImportResource:导入Spring的配置文件，让配置文件里面的内容生效；\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n想让Spring的配置文件生效；**@ImportResource**标注在一个配置类上\n@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)\n导入spring的配置文件\n\nSpringBoot推荐给容器中添加组件的方式：推荐使用全注解方式\n1、配置类====Spring配置文件\n2、使用@Bean给容器中添加组件\n/*\n    @Configuration:指明当前类是一个配置类；就是来替代之前的Spring配置文件\n    在配置文件中用&lt;bean>&lt;bean/>标签添加组件\n */\n@Configuration\npublic class MyAppConfig &#123;\n    // 将方法的返回值添加到容器中，容器中的这个组件默认的id就是方法名\n    @Bean\n    public HelloService helloService() &#123;\n        System.out.println(\"helloService已添加\");\n        return new HelloService();\n    &#125;\n&#125;\n\n2.4、配置文件占位符2.4.1、随机数random.value\nrandom.int\n$&#123;random.long&#125;\nrandom.int(10)\n&#123;random.int[1024, 65536]&#125;\n\n2.4.2、点位符获取之前配置的值，如果没有可以用：号来指定默认值person.name=张三$&#123;random.uuid&#125;\nperson.age=$&#123;random.int&#125;\nperson.list=a,b,c\nperson.map.k1=aaa\nperson.map.k2=bbb\nperson.dog.name=$&#123;person.wq: zhu&#125;dog\n\n2.5、Profile,测试环境，正式环境配置2.5.1、多Profile文件我们在主配置文件编写的时候，文件名可以是： application-{profile}.properties/yml\n\n2.5.2、yml支持多文档块方式spring:\n  profiles:\n    active: dev\n    \n---\nserver:\n  port: 8020\nspring:\n  profiles: dev\n  \n---\nserver:\n  port: 8030\nspring:\n  profiles: prod\n\n\n\n\n2.5.3、激活指定profile1、\nspring.profiles.active=dev\n\n2、命令行：\njava -jar ***.jav --spring.profiles.active=dev\n可以直接在测试的时候，配置传入命令行参数\n\n\n\n\n3、虚拟机参数\n-Dspring.profiles.active=dev\n\n\n2.6、配置文件加载位置. spring boot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\n# 配置项目的访问路径\nserver.context-path=/boot02\n\n\nfile:./config/\nfile:./\nclasspath:/config/\nclasspath:/\n一以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容。\nSpringBoot会从四个位置全部加载主配置文件；互补配置；\n我们也可以通过配置spring.config.location来改变默认配置；\n\n项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指配置文件和默认加载的这些配置文件共同起作用形成互补配置；\n2.7、外部配置加载顺序SpringBoot民可以从以下位置加载配置；优先级从高到低；高优先级的配置覆盖低优先级的配置\n\n命令行参数\n\njava -jar *.jar --server.port=8087 --server.context-path=/abc\n// 多个配置用空格分开；--配置项=值\n\n\n来自java:comp/env的JNDI属性\n\njava系统属性（System.getProperties()）\n\n操作系统环境变量\n\nRandomValuePropertySource配置的random.*属性值\n由jar包外向jar包内进行寻找；\n优先加载带profile\n\njar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n\njar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n再来加载不带profile\n\njar包外部的application.properties或application.yml(不带spring.profile)配置文件\n\njar包内部的application.properties或application.yml(不带spring.profile)配置文件\n\n@Configuration注解类上的@PropertySource\n\n通过SpringApplication.setDefaultProperties指定的默认属性\n\n\n2.8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理；\n配置文件能配置的属性参照 \n自动配置原理：\n1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoCOnfiguration\n2）、@EnableAutoConfiguration作用；\n​    利用EnableAutoConfigurationImportSelector给窗口中导入一些组件？\n​    可以插件selectImports()方法的内容；\n​    List configurations = getCandidateConfigurations(annotationMetadata, attributes);\n三、Spring Boot与日志四、Spring Boot与Web开发五、Spring Boot与Docker六、Spring Boot与数据访问七、Spring Boot启动配置原理八、Spring Boot自定义starters九、Spring Boot与缓存十、Spring Boot与消息十一、Spring Boot与检索十二、Spring Boot与任务十三、Spring Boot与安全十四、Spring Boot与分布式十五、Spring Boot与开发热部署十六、Spring Boot与监控管理","slug":"SpringBoot","date":"2021-05-31T03:42:36.000Z","categories_index":"SpringBoot","tags_index":"Java,SpringBoot","author_index":"阿朱"},{"id":"6b52f6e39f338d64bbb358fbefb34421","title":"92反转链表","content":"给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表\n输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5]示例 2：\n输入：head = [5], left = 1, right = 1输出：[5]\n解法1 穿针引线法\nclass Solution:\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\n        def reverse_list_node(head: ListNode):\n            cur = None\n            pre = head\n            while pre:\n                tmp_pre = pre.next\n                pre.next = cur\n                cur = pre\n                pre = tmp_pre\n\n        # pre  lft  rgt  succ\n        vitural_node = ListNode(0, head)\n        pre = vitural_node\n        # 1、pre走到left - 1 的前一个节点\n        for _ in range(left - 1):\n            pre = pre.next\n        \n        rgt = pre \n        # 2、 从pre走到right 节点\n        for _ in range(right - left + 1):\n            rgt = rgt.next\n\n        lft = pre.next\n        succ = rgt.next\n        # 3、截断lft 和rgt\n        pre.next = None\n        rgt.next = None\n\n        # 4、反转\n        reverse_list_node(lft)\n        # 5、拼接\n        pre.next = rgt\n        lft.next = succ\n        return vitural_node.next","slug":"92反转链表","date":"2021-05-28T13:33:34.000Z","categories_index":"","tags_index":"","author_index":"阿朱"},{"id":"89c34e44426aa942dcf00a2b48cf6d75","title":"Python合并文件夹下的PDF","content":"Python合并文件夹下的PDF今天本来想用WPS来合并PDF，发现他要钱；接着找了几个软件，都要收费，我一下火就上来了；充钱是不可能充钱的，我试了下用Python写一个，发现成了，也没有乱码现象，直接上代码，copy就能用；\n版本PyPDF2==1.26.0Python39\nfrom PyPDF2 import PdfFileMerger\nimport os\n\n\ndef merger_dir_pdf():\n    \"\"\"\n    合并文件夹下的所有pdf文件\n    :return: 无  在对应文件夹下会输出文件\n    \"\"\"\n    # 修改此路径（全路径）即可，后面记得加 / 斜杠\n    DIR = \"D:/放pdf的文件夹/\"\n\n    files = os.listdir(DIR)  # 列出目录中的所有文件\n    merger = PdfFileMerger()\n    \n    for file in files:\n        if file[-4:] == \".pdf\":\n            merger.append(open(DIR + file, 'rb'))\n    \n    with open(DIR + '合并后.pdf', 'wb') as file_out:\n        merger.write(file_out)\n\n\ndef main():\n    merger_dir_pdf()\n\nif __name__ == \"__main__\":\n    main()","slug":"Python合并文件夹下的PDF","date":"2021-05-22T14:22:12.000Z","categories_index":"算法","tags_index":"Python,小工具","author_index":"阿朱"},{"id":"212b0c02273b747bf0747e812cb176a2","title":"15三数之和","content":"给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n \n示例 1：\n输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]示例 2：\n输入：nums = []输出：[]示例 3：\n输入：nums = [0]输出：[]\n解法1：双指针 528ms   击败：97.74%class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n\t\t# 双指针\n        ans = list()\n        nums_len = len(nums)\n        nums.sort()\n        for first in range(nums_len - 2):\n            # 第一个数大于0，那么3个数相加就不可能等于0了\n            if nums[first] > 0:\n                continue\n            if first >= 1 and nums[first] == nums[first - 1]:\n                continue\n\n            second = first + 1\n            third = nums_len - 1\n            \n            while second &lt; third:\n               \t\n                tar = nums[first] + nums[second] + nums[third]\n                # 大于0\n                if tar > 0:\n                    third -= 1\n                # 小于0\n                elif tar &lt; 0:\n                    second += 1\n                # 等于0\n                else:\n                    ans.append([nums[first], nums[second], nums[third]])\n                    # 中指针，与前一个数相等的直接跳过\n                    while second &lt; third and nums[second + 1] == nums[second]:\n                        second += 1\n                    # 右·指针，与前一个数相等的直接跳过\n                    while second &lt; third and nums[third - 1] == nums[third]:\n                        third -= 1\n                    third -= 1; second += 1\n        return ans","slug":"15三数之和","date":"2021-05-18T01:27:01.000Z","categories_index":"","tags_index":"","author_index":"阿朱"},{"id":"d01fb00841d955d4f1e65e30fbb4f017","title":"70爬楼梯","content":"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意：给定 n 是一个正整数。\n示例 1：\n输入： 2输出： 2解释： 有两种方法可以爬到楼顶。\n\n1 阶 + 1 阶\n\n2 阶\n\n\n示例 2：\n输入： 3输出： 3解释： 有三种方法可以爬到楼顶。\n\n 1 阶 + 1 阶 + 1 阶\n 1 阶 + 2 阶\n 2 阶 + 1 阶\n\n解法1：动态规划 36msclass Solution:\n\tdef climbStairs(self, n: int) -> int:    \n\t\tallways = [1] + [0] * n\n\t\tfor i in range(1, n+1):\n\t\t\tallways[i] = allways[i - 1] + allways[i - 2]\n\t\treturn allways[-1]\n\n\n\n解法2：循环暴力 44msclass Solution:\n    def climbStairs(self, n: int) -> int:\n\t\ta = b = 1\n        for _ in range(n):\n            a, b = b, a+b\n        return a\n解法3：递归class Solution:\n\tdef climbStairs(self, n: int) -> int:   \n\t\tmemo = [0 for i in range(n+1)]\n        if memo[n] > 0:\n            return memo[n]\n        if n == 1:\n            memo[n] = 1\n        elif n == 2:\n            memo[n] = 2\n        else:\n            memo[n] = self.climbStairs(n - 1) + self.climbStairs(n - 2)\n        return memo[n]","slug":"70爬楼梯","date":"2021-05-17T11:22:16.000Z","categories_index":"算法","tags_index":"算法,Python,递归,动态规划","author_index":"阿朱"},{"id":"fa4bbc9028ee856d8c505acb6623406b","title":"数据结构与算法-1","content":"一、数据结构\n一维：\n\n基数：数组array(String) , 链表 linked list\n高级：栈 stack, 队列 queue , 双端队列 deque, 集合 set , 映射 map(hash or map), etc\n\n\n二维：\n\n 基础：树 tree, 图 graph\n 高级：二叉搜索树 binary search tree (red-black tree, AVL), 堆 heap, 并查集 disjoint set, 字典树 Trie , etc\n\n\n特殊：\n\n位运算 Bitwise, 布隆过滤器 BloomFitter\nLRU Cache\n\n\n\n二、算法\nif-else, swithch -&gt; branch\nfor, while loop -&gt; lteration\n递归 Recursion (Divide &amp; Conquer, Backtrace)\n\n\n搜索Search: 尝试优先搜索 Depath first search, 广度优先搜索 Braeadth first search , A* , etc\n动态规划 Dynamic Programming\n二分查找 Binary Search\n贪心 Greedy\n数据 Math, 几何 Geometry\n注意在头脑中回忆上面每种算法的思想和代码模块*\n\n2.1 算法结构脑图\n2.2 数据结构脑图\n三、切题四件套\nClarification\nPossible solutions\ncompare(time/space)\noptimal（加强）\n\n\nCoding (多写)\nTest cases\n\n3.1 刷题第一遍\n5分钟：读题+思考 \n直接看解法：注意！多解法，比较解法优劣\n背诵、默写好的解法\n\n3.2 刷题第二遍\n马上自己写 –》LeetCode提交\n多种解法比较、体会 –》优化！\n\n四、时间复杂度\n二叉树遍历- 前序、中序、后序： 时间复杂度是多少？  O(n)\n图的遍历 ： 时间复杂度是多少? O(n)\n搜索算法： DFS、BFS时间复杂度是多少？ O(n)\n二分查找：时间复杂度是多少？ Logn\n\n五、数组、链表、跳表5.1 链表时间复杂度\nprepend    O(1)\nappend    O(1)\nlookup    O(n)\ninsert    O(1)\ndelete    O(1)5.1.1 如何给链表加速\n\n\n5.2 跳表\n时间复杂度：O(logn)\n\n空间复杂度：O(n)\n\n索引的高度：logn, 每层索引遍历的结点个数：3\n\n在跳表中查询任意数据的时间复杂度就是O(logn)\n\n\n\n\n5.3 List 时间复杂度\nprepend    O(1)\nappend    O(1)\nlookup    O(1)\ninsert    O(n)\ndelete    O(n)\n\n5.4 小结\n数组、链表、跳表的原理和实现\n三者的时间复杂度、空间复杂度\n工程运用\n跳表：升维思想+空间换时间\n\n","slug":"数据结构与算法-1","date":"2021-05-14T11:52:49.000Z","categories_index":"算法","tags_index":"算法,Python","author_index":"阿朱"},{"id":"378da439daa2ee05d165c8ebd4326ea7","title":"1734解码异或的排列","content":"给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。示例 1：输入：encoded = [3,1]输出：[1,2,3]解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]\n示例 2：输入：encoded = [6,5,4,6]输出：[2,4,1,5,3]\n此题是leetcode 1720的升级版\n一、解法一：通过数据解题思路（异或运算）1.1 思路我在LeetCode上面看题解的时候，看得好吃力，完全没看懂，然后跟着思路用纸写一遍，突然就懂了。话不多说，开始：\n我们知道异或运算有如下性质（不懂的话，可以查一下，不多做解释了）：\n\n相同数值异或，结果为 0\n任意数值与 0 进行异或，结果为数值本身\n异或本身满足交换律\n\n⊕：代表异或\n本题需要我们求perm（需求一步一步往下看，不然会不懂）\n\n根据题目意思 ，假设 perm = [a, b, c, d, e]，那么 encoded = [ab, bc, cd, de]\n\n先求出perm[0]  ,    perm[0] =   (perm[0] ⊕ perm[1] … ⊕ perm[n] )  ⊕    (perm[1] …⊕ perm[n] )   ,根据相同值异或为0性质，异或结果就是perm[0]，看懂了再往下走\n\n此时我们只需要求出**(perm[0] ⊕ perm[1] … ⊕ perm[n] )** 和**(perm[1] …⊕ perm[n] )的值，他俩异或的结果就可以求出perm[0]**\n\n\n求第2步的两个值：\n\n(perm[0] ⊕ perm[1] … ⊕ perm[n] )，题目已经告诉我们的，他是前 n 个正整数的排列，假如n=5 ,他结果就是1⊕ 2⊕ 3⊕ 4⊕ 5,\n(perm[1] …⊕ perm[n] ),这个值看如下举例：\n\n假设 perm = [a, b, c, d, e]，那么 encoded = [ab, bc, cd, de]\nperm[1] ⊕ perm[2] …⊕ perm[n]  =  encoded[1] ⊕ encoded[3]   (步长为2)\n\nencoded都是题目给出来的值 ，是不是很好求\n这样你就可以结合第二步，求出**perm[0]**的值\n\n\n题目给出encoded[i] = perm[i] ⊕ perm[i + 1]    可以理解为：encoded[i] = perm[i] ⊕ perm[i - 1]    一样的意思， 只是我把下标 i理解为当前这个数和当前数的前一个\n\n​    encoded[0] = perm[0] ⊕ perm[1]  两边同时异或 perm[1],  根据相同为0，得出如下\n​    perm[1] = encoded[0] ⊕ perm[0]\n​    perm[i] = encoded[i] ⊕ perm[i - 1]\n\n\n\n最后再去看代码，就很清晰了，总结的不好的，欢迎留言指正；\nclass Solution:\n    def decode(self, encoded: List[int]) -> List[int]:\n        n = len(encoded) + 1\n        \n        perm_total = reduce(xor, range(1, len(encoded) + 2))\n        \n        child_total = 0\n        for i in range(1, len(encoded), 2):\n            child_total ^= encoded[i]\n           \n        perm = [perm_total ^ child_total]\n        \n        for j in range(1, len(encoded) + 1):\n            perm.append(encoded[j - 1] ^ perm[j - 1])\n        return perm\n\n\n\n\n\n","slug":"1734解码异或的排列","date":"2021-05-12T04:29:27.000Z","categories_index":"算法","tags_index":"算法,Python,异或","author_index":"阿朱"},{"id":"d4cfe049c5b6be882045489e2054f761","title":"TCP和UDP协议","content":"TCP的三次握手和四次挥手\n","slug":"TCP和UDP协议","date":"2021-05-10T07:43:32.000Z","categories_index":"网络","tags_index":"TCP,UDP","author_index":"阿朱"},{"id":"fdf447c09b614244b1d615663633680c","title":"169多数元素","content":"给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n一、解法一 使用消除法此解法扣重点：出现次数会大于【n/2】的元素\n（1）从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个，以一换一去换，最多的那一队，怎么都会多1个。\n使用举例：\n​        现在去打战，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利，其他国家的人相互攻击，只要不打内战，只有赢家能扛到最后，可以通过这个思路先自己写一遍代码，写不出，可以参考以下，如有不好的地方，可以评论留言。\ndef majorityElement(self, nums: List[int]) -> int:\n    count = 0\n    re_nu = -1\n    for num in nums:\n        if num == re_nu:\n            count += 1\n        else:\n            if count == 0:\n                re_nu = num\n                continue\n            count -= 1\n    return re_nu\n\n\n\n\n二、解法二 使用Hash这就不多做解释了，看代码吧\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        hashtable = dict()\n        for num in nums:\n            if num in hashtable:\n                hashtable[num] = hashtable[num] + 1\n            else:\n                hashtable[num] = 1\n        # 获取dict value最大的key值。\n        return max(hashtable, key=hashtable.get)\n\n","slug":"169多数元素","date":"2021-05-06T13:19:52.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"35c279d773f512ff2cf029127b15b0e0","title":"136只出现一次的数字 LeetCode","content":"题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n说明：\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n示例 1:\n输入: [2,2,1]输出: 1示例 2:\n输入: [4,1,2,1,2]输出: 4\n主要学习解法2\n一、解法1，使用set()set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等\n代码比较简单，不做过多的解释，看看就懂。\ndef singleNumber(self, nums: List[int]) -> int:\n    num_set = set()\n    for num in nums:\n        if num in num_set:\n            num_set.remove(num)\n        else:\n            num_set.add(num)\n    return list(num_set)[0]\n\n\n\n\n二、解法2，使用异或运算⊕: 异或符号\n答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。\n\n任何数和 0 做异或运算，结果仍然是原来的数，即 a ⊕ 0=a\n\n任何数和其自身做异或运算，结果是 0，即 a  ⊕ a=0\n\n异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b（简单来说，就是不管异或的顺序如何，最终结果都是一样的，本解法，关键就是利用这一点）\n\n\n  交换律和结合律详解    比如:\na=1,b=2,c=2,d=4,e=4\na ^ d ^ c ^ b ^ e == b ^ c ^ d ^ e ^ a  == 1\t\n# 不管顺序如何,如果都是一样,结果都是一样\n\n博主思考：\n\n写完这个题的时候,我就在床上思考, 如果a⊕a = 0,那么a⊕a⊕a呢,那他就不是0了,怎么可以求得解呢?\n\n答:就在这时,我去重新看了一眼题目,题目表明了,每个数都只出现两次,只有一个数出现了一次,审题得仔细.\n也可以把这个思考当做一个新题目去做,在一堆不确定出现次数的数中,找出只出现了一次的数,又或者是在一堆数字中,找出现次数最少的数字\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        re_num = 0\n        for num in nums:\n            re_num = num ^ re_num\n        return re_num\n\n\n\n\n\n","slug":"136只出现一次的数字","date":"2021-05-05T12:27:25.000Z","categories_index":"算法","tags_index":"算法,Python,异或","author_index":"阿朱"},{"id":"be827bd3744cf66f970afc1974c2f8ba","title":"237删除链表中的节点 leetCode","content":"题目：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。这个题一开始，我也有点懞，被这个题目弄傻了。后面看了下题解，豁然开朗。\n主要思路\n\n将下一个节点的值赋值给当前节点\n\n然后把下一个节点删除即可（删除方法：将当前节点next指向下一个节点的next）\n\n\nclass Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next","slug":"237删除链表中的节点","date":"2021-05-05T12:03:58.000Z","categories_index":"算法","tags_index":"算法,Python,链表","author_index":"阿朱"},{"id":"9319bb79084ec16cc2b86c7f0a8d2c6a","title":"Django","content":"Django程序开机自动启动\n通过shell脚本，设置开机自动启动Django的uwsgi服务（测试环境Cento8）\n1、切换到/etc/init.d/，目录下创建一个自己的脚本2、制作sh脚本 vim start_uwsgi注意，注释也要加进去\n#!/bin/sh\n#add for chkconfig\n#chkconfig: 2345 70 30\n#description: the description of the shell   #关于脚本的简短描述\n#processname: andyStart      #第一个进程名，后边设置自启动的时候会用到\n#下面要启动服务的命令\nsource /418pro/env/djangoVenv/bin/activate &amp;&amp; uwsgi --ini /418pro/uwsgi-configs/django.ini   #进入虚拟环境 &amp;&amp; 启动uwsgi 配置文件的具体位置\n\n说明：\n（1）2345是指脚本的运行级别，即在2345这4种模式下都可以运行，234都是文本界面，5就是图形界面X\n（1）70是指脚本将来的启动顺序号，如果别的程序的启动顺序号比70小（比如44、45），则脚本需要等这些程序都启动以后才启动。\n（1）30是指系统关闭时，脚本的停止顺序号。\nlinux 下shell脚本执行多个命令的方法\n(1)每个命令之间用;隔开\n说明：各命令的执行给果，不会影响其它命令的执行。换句话说，各个命令都会执行，但不保证每个命令都执行成功。\n(2)每个命令之间用&amp;&amp;隔开\n说明：若前面的命令执行成功，才会去执行后面的命令。这样可以保证所有的命令执行完毕后，执行过程都是成功的。\n(3)每个命令之间用||隔开\n说明：||是或的意思，只有前面的命令执行失败后才去执行下一条命令，直到执行成功一条命令为止。\n3、给脚本加上可执行权限：chmod a+x start_uwsgi\n\n\n4、利用chkconfig命令将脚本设置为自启动：chkconfig --add start_uwsgi\n\n\n","slug":"Django","date":"2021-05-05T06:39:18.000Z","categories_index":"Django","tags_index":"Python,Django","author_index":"阿朱"},{"id":"5657dbaafc65d44bb7226a49ee6df3c8","title":"nginx","content":"设置开机自动启动\nnginx开机自动启动(Centos8测试环境)\n1、init.d下创建文件nginxvim /etc/init.d/nginx\nnginx官方文档\n2、将官方配置，添加到编辑的文件中：nginx=”/usr/local/nginx/sbin/nginx” //修改成nginx执行程序的路径。\nNGINX_CONF_FILE=”/usr/local/nginx/conf/nginx.conf” //修改成nginx.conf文\n件的路径。\n3、保存后设置文件的执行权限chmod a+x /etc/init.d/nginx\n\n4、通过下面指令控制启动停止/etc/init.d/nginx start\n/etc/init.d/nginx stop\n查看进程命令\nps aux | grep nginx\n也可以通过kill掉pid来关闭进程\n5、上面测试通过后、将nginx服务加入chkconfig管理列表：chkconfig --add /etc/init.d/nginx\n\n6、加完5之后，可以使用service对nginx进行启动，重启等操作。service nginx start\nservice nginx stop\nservice nginx restart\n7、最后设置开机自动启动chkconfig nginx on\n\n\n","slug":"nginx","date":"2021-05-05T04:39:04.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"阿朱"},{"id":"b0332e478f2510b18d9d570091b0d2de","title":"整数反转 leetCode 7","content":"给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）\n1、解法1，未优化写法   40ms思路：\n展开我的思路\n   （1）这个题挺简单，就是通过%运算，每次都取到数的最后一位   （2）考虑到负数的问题，所以while那里使用了 x!=0，因为按这种方式计算，最后都会为0   （3）注意题目规定的整数范围，这里代码做了提前一位的判断。看下图解\n   \n   第二排数字中，橘子的是5，它是大于上面同位置的4，这就意味着5后跟任何数字，都会比最大32为整数都大。   所以，我们到【最大数的1/10】时，就要开始判断了   如果某个数字大于 214748364那后面就不用再判断了，肯定溢出了。   如果某个数字等于 214748364呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的末尾数字比较，如果这个数字比7还大，说明溢出了。\n负数也是一样：\n\n上图中绿色部分是最小的32位整数，同样是在【最小数的 1/10】时开始判断如果某个数字小于 -214748364说明溢出了如果某个数字等于 -214748364，还需要跟最小数的末尾比较，即看它是否小于8\n\n\n遇到问题：因为Python 的%运算，是使用的floor的方式，在计算负数的时候，会出现和Java不同，所以，都转成正数来取模运算\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        reverse_num = 0\n        # 2147483647\n        # -2147483648\n        while(x != 0):\n            if x &lt; 0:\n                tmp_num = -x % 10\n                tmp_num = -tmp_num\n            else:\n                tmp_num = x % 10\n            # 判断是否溢出\n            if (reverse_num > 214748364) or (reverse_num == 214748364 and tmp_num > 7):\n                return 0\n            if (reverse_num &lt; -214748364) or (reverse_num == 214748364 and tmp_num > 7):\n                return 0\n            reverse_num = reverse_num * 10 + tmp_num\n            x = int(x/10)\n        return reverse_num\n\n2、 将解法1所写的代码进行优化   32msclass Solution:\n    def reverse(self, x: int) -> int:\n        # 2147483647\n        # -2147483648\n        y, res = abs(x), 0\n        while(y != 0):\n            tmp_num = y % 10\n            # 判断是否溢出\n            if res &lt; -214748364:\n                return 0\n            if (res > 214748364) or (res == 214748364 and tmp_num > 7):\n                return 0\n            res = res * 10 + tmp_num\n            y = int(y/10)\n        return res if x > 0 else -res\n\n3、使用字符串反转的方法  36msclass Solution:\n    def reverse(self, x: int) -> int:\n        y = str(x)\n        ins = 1\n        res = \"\"\n        if y[0] == \"-\":\n            ins = -1\n            res = y[1:][::-1]\n        else:\n            res = y[::-1]\n        nums = int(res)\n        return 0 if nums &lt;-2**31 or nums > 2**31-1 else (ins * nums)\n\n题目总结：在用字符串反转的方法时，我发现Ptyhon这样将字符串进行转换，整型不会内存溢出，很好奇的我，去网上查阅了资料，发现Python3之后，都是统一使用了长整型\n\n现在是2021年5月4号零晨1:45分，这是我刷leetcode的第三道题，每次将自己写的一串很长的代码，优化成很简单，看着自己的代码运行时间越写越短，内心有一点无比自豪的感觉，很喜欢这种超越自己的，继续加油吧。哈哈哈哈哈哈\n","slug":"7整数反转","date":"2021-05-03T16:27:50.000Z","categories_index":"算法","tags_index":"算法,Python","author_index":"阿朱"},{"id":"b529ed6ebbafadec850827aed7fed9b6","title":"两数之和 leetCode 1","content":"题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案\n\n\n示例 1：\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2：\n输入：nums = [3,2,4], target = 6输出：[1,2]示例 3：\n输入：nums = [3,3], target = 6输出：[0,1]\n解法1  Hash表解法思路：1、hash表存入的数据key:nums , value :对应下标使用目标值target减去数组中的每一个数，如果得到的值，不在hash表中，继续循环，如果存在，那说明是要找的数，直接返回两个下标。\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_table = dict()\n        for i,num in enumerate(nums):\n            if target - num in hash_table:\n                return [hash_table[target - num], i]\n            hash_table[num] = i\n\n\n\n","slug":"两数之和","date":"2021-05-03T11:55:20.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"5234a8c4e062136329f4963c94cde8ba","title":"砖墙问题 leetCode 554","content":"题目：你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。\n你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。\n给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 \n\n输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]输出：2示例 2：\n输入：wall = [[1],[1],[1]]输出：3\n\n\n1、题目分析\n题目要求穿过的砖块数量最少，等效于通过他的间隙最多\n将所有行总数，减去间隙，就是穿过最少的砖块数\n记住，每行的间隙位置，就是砖的左侧宽度和\n\n\n\n第 1 行的间隙有 [1,3,5]\n第 2 行的间隙有 [3,4]\n第 3 行的间隙有 [1,4]\n第 4 行的间隙有 [2]\n第 5 行的间隙有 [3,4]\n第 6 行的间隙有 [1,4,5]\n\n\n上述的每行的每个值，代表间隙位置，单行的间隙位置不会相同出\n统计间隙数，最后用总行数减去出现次数，即得到【最少穿过砖块数】\n\n解法1：使用hash表  52msclass Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        hashtable = dict()\n        for w in wall:\n            # 记录每一块砖缝，出现次数\n            ans = 0   # 每一行墙，墙缝 \n            # 最后一块砖的墙缝不算, [:-1]代表只取到倒数每二个数\n            for num in w[:-1]:\n                # 统计墙缝\n                ans += num\n                hashtable[ans] = hashtable.get(ans, 0) + 1\n        # 判断，所有行只有一块砖，就直接穿过所有\n        if not hashtable:\n            return len(wall)\n        return len(wall) - max(hashtable.values())\n    \n\n\n```\n","slug":"砖墙问题","date":"2021-05-03T06:22:29.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"901b553f2ebc4e976cd70013f9320085","title":"vim操作宝典","content":"在行尾插入视图模式：a 键\n\nVim显示文件已经打开非正常退出，就会产生.swp文件，可以把他删除\nrm -rf .文件名.swp\t\t\n\n复制多行数字键加yy\n例：复制4行\n4yy\n在行上方或者下方插入两个都是字母\no：在下方\nO：在上方\n\n合并两行视图模式：J\n\n多行注释（1）首先按键盘上的ESC进入命令行模式\n（2）再按Ctrl+V进入VISUAL BLOCK模式\n（3）利用上下左右键调整需要注释多少行以及行的宽度\n（4）再按Shift+i或s进入插入模式\n（5）输入代表注释的符号，比如#\n（6）再次按ESC键，这时就可完成多行注释（可能需要等上一会，不要着急）\n\n\n去注释（1）:起始行号,结束行号s/^/注释符/g\n打开目录nt\n\n纵向分屏，复制当前窗口: vsp\n在当前窗口切换编辑文件: e 文件路径\n\n粘贴历史行\"3p  （中间数字1到9）","slug":"vim操作宝典","date":"2021-05-01T12:41:12.000Z","categories_index":"Vim","tags_index":"Linux,Vim","author_index":"阿朱"},{"id":"83638110e00c80fbf85ca941956c7a6d","title":"linux操作宝典","content":"按内容搜索所有文件grep -rn &quot;hello,world!&quot; *\n\n* 表示当前目录所有文件，也可以是某个文件名\n-r 是递归查找\n-n 是显示行号\n-R 查找所有文件包含子目录\n-i 忽略大小写\n-l 只列出匹配的文件名\n-L 列出不匹配的文件名\n-w 只匹配整个单词，而不是字符串的一部分（匹配 hello，不匹配helloo）\n\n排查内存占用1.排查磁盘满的节点，执行以下命令：df -h\n\n2.进入df -h查出的异常分区，执行以下命令，逐层往下找出耗磁盘的目录。du -sh * | grep G\n\n3.进入消耗磁盘的目录，找出消耗磁盘空间的异常文件，执行命令：du -sh * | grep G 或者 du -sh * | grep T\n\n4.删除查找出来的异常文件命令：rm -rf 文件名\n\n5.如果上面找不出异常文件消耗磁盘空间，有可能是已删除文件但未释放内存，占用了很大的空间，执行命令：lsof -n | grep delete\n\n6.找出已删除的文件但未释放内存的进程，然后释放进程。kill -9 进程号","slug":"linux","date":"2021-04-29T06:33:15.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"阿朱"},{"id":"9a2252c0b559cb77f268bff5416cc06f","title":"shell脚本","content":"清屏clear\n输出换行，两个echo -e \"\\n\\n\"\n休息一秒sleep 1\n输出用户数who | awk '&#123;print $1&#125;' | sort | uniq | wc -l\n让计算机发出蜂鸣声echo -en \"\\007\"\n\n判断文件夹是否存在if [ ! -d \"./QQ/\" ];\nthen\n  mkdir QQ\nelse\n  echo \"文件夹存在\"\nfi\n文件目录追加到文件中ls >> 文件名\n\n输出白底黑字的文字echo -e \"\\033[47;30m Now at your service,*Zhu-Zhi-Wu* \\033[0m\"\n\n监听键盘输入任意键read -n 1 -p \"the End…\"\n\n\n\n输入三个数，输出最大数printf \"请输入三个书：\\n\"\nread first_num\nread secend_num\nread thd_num\nif [ $first_num -gt $secend_num ]\nthen\n  max=$first_num\nelse\n  max=$secend_num\nfi\n\nif [ $thd_num -gt $max ]\nthen\n  max=$thd_num\nfi\n\necho \"$max\"","slug":"shell脚本","date":"2021-04-25T03:42:36.000Z","categories_index":"Shell","tags_index":"Linux,Shell","author_index":"阿朱"}]
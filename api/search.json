[{"id":"9319bb79084ec16cc2b86c7f0a8d2c6a","title":"Django","content":"Django程序开机自动启动\n通过shell脚本，设置开机自动启动Django的uwsgi服务（测试环境Cento8）\n1、切换到/etc/init.d/，目录下创建一个自己的脚本2、制作sh脚本 vim start_uwsgi注意，注释也要加进去\n#!/bin/sh\n#add for chkconfig\n#chkconfig: 2345 70 30\n#description: the description of the shell   #关于脚本的简短描述\n#processname: andyStart      #第一个进程名，后边设置自启动的时候会用到\n#下面要启动服务的命令\nsource /418pro/env/djangoVenv/bin/activate &amp;&amp; uwsgi --ini /418pro/uwsgi-configs/django.ini   #进入虚拟环境 &amp;&amp; 启动uwsgi 配置文件的具体位置\n\n说明：\n（1）2345是指脚本的运行级别，即在2345这4种模式下都可以运行，234都是文本界面，5就是图形界面X\n（1）70是指脚本将来的启动顺序号，如果别的程序的启动顺序号比70小（比如44、45），则脚本需要等这些程序都启动以后才启动。\n（1）30是指系统关闭时，脚本的停止顺序号。\nlinux 下shell脚本执行多个命令的方法\n(1)每个命令之间用;隔开\n说明：各命令的执行给果，不会影响其它命令的执行。换句话说，各个命令都会执行，但不保证每个命令都执行成功。\n(2)每个命令之间用&amp;&amp;隔开\n说明：若前面的命令执行成功，才会去执行后面的命令。这样可以保证所有的命令执行完毕后，执行过程都是成功的。\n(3)每个命令之间用||隔开\n说明：||是或的意思，只有前面的命令执行失败后才去执行下一条命令，直到执行成功一条命令为止。\n3、给脚本加上可执行权限：chmod a+x start_uwsgi\n\n\n4、利用chkconfig命令将脚本设置为自启动：chkconfig --add start_uwsgi\n\n\n","slug":"Django","date":"2021-05-05T06:39:18.000Z","categories_index":"Django","tags_index":"Python,Django","author_index":"阿朱"},{"id":"5657dbaafc65d44bb7226a49ee6df3c8","title":"nginx","content":"设置开机自动启动\nnginx开机自动启动(Centos8测试环境)\n1、init.d下创建文件nginxvim /etc/init.d/nginx\nnginx官方文档\n2、将官方配置，添加到编辑的文件中：nginx=”/usr/local/nginx/sbin/nginx” //修改成nginx执行程序的路径。\nNGINX_CONF_FILE=”/usr/local/nginx/conf/nginx.conf” //修改成nginx.conf文\n件的路径。\n3、保存后设置文件的执行权限chmod a+x /etc/init.d/nginx\n\n4、通过下面指令控制启动停止/etc/init.d/nginx start\n/etc/init.d/nginx stop\n查看进程命令\nps aux | grep nginx\n也可以通过kill掉pid来关闭进程\n5、上面测试通过后、将nginx服务加入chkconfig管理列表：chkconfig --add /etc/init.d/nginx\n\n6、加完5之后，可以使用service对nginx进行启动，重启等操作。service nginx start\nservice nginx stop\nservice nginx restart\n7、最后设置开机自动启动chkconfig nginx on\n\n\n","slug":"nginx","date":"2021-05-05T04:39:04.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"阿朱"},{"id":"b0332e478f2510b18d9d570091b0d2de","title":"整数反转 leetCode 7","content":"给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）\n1、解法1，未优化写法   40ms思路：\n展开我的思路\n   （1）这个题挺简单，就是通过%运算，每次都取到数的最后一位   （2）考虑到负数的问题，所以while那里使用了 x!=0，因为按这种方式计算，最后都会为0   （3）注意题目规定的整数范围，这里代码做了提前一位的判断。看下图解\n   \n   第二排数字中，橘子的是5，它是大于上面同位置的4，这就意味着5后跟任何数字，都会比最大32为整数都大。   所以，我们到【最大数的1/10】时，就要开始判断了   如果某个数字大于 214748364那后面就不用再判断了，肯定溢出了。   如果某个数字等于 214748364呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的末尾数字比较，如果这个数字比7还大，说明溢出了。\n负数也是一样：\n\n上图中绿色部分是最小的32位整数，同样是在【最小数的 1/10】时开始判断如果某个数字小于 -214748364说明溢出了如果某个数字等于 -214748364，还需要跟最小数的末尾比较，即看它是否小于8\n\n\n遇到问题：因为Python 的%运算，是使用的floor的方式，在计算负数的时候，会出现和Java不同，所以，都转成正数来取模运算\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        reverse_num = 0\n        # 2147483647\n        # -2147483648\n        while(x != 0):\n            if x &lt; 0:\n                tmp_num = -x % 10\n                tmp_num = -tmp_num\n            else:\n                tmp_num = x % 10\n            # 判断是否溢出\n            if (reverse_num > 214748364) or (reverse_num == 214748364 and tmp_num > 7):\n                return 0\n            if (reverse_num &lt; -214748364) or (reverse_num == 214748364 and tmp_num > 7):\n                return 0\n            reverse_num = reverse_num * 10 + tmp_num\n            x = int(x/10)\n        return reverse_num\n\n2、 将解法1所写的代码进行优化   32msclass Solution:\n    def reverse(self, x: int) -> int:\n        # 2147483647\n        # -2147483648\n        y, res = abs(x), 0\n        while(y != 0):\n            tmp_num = y % 10\n            # 判断是否溢出\n            if res &lt; -214748364:\n                return 0\n            if (res > 214748364) or (res == 214748364 and tmp_num > 7):\n                return 0\n            res = res * 10 + tmp_num\n            y = int(y/10)\n        return res if x > 0 else -res\n\n3、使用字符串反转的方法  36msclass Solution:\n    def reverse(self, x: int) -> int:\n        y = str(x)\n        ins = 1\n        res = \"\"\n        if y[0] == \"-\":\n            ins = -1\n            res = y[1:][::-1]\n        else:\n            res = y[::-1]\n        nums = int(res)\n        return 0 if nums &lt;-2**31 or nums > 2**31-1 else (ins * nums)\n\n题目总结：在用字符串反转的方法时，我发现Ptyhon这样将字符串进行转换，整型不会内存溢出，很好奇的我，去网上查阅了资料，发现Python3之后，都是统一使用了长整型\n\n现在是2021年5月4号零晨1:45分，这是我刷leetcode的第三道题，每次将自己写的一串很长的代码，优化成很简单，看着自己的代码运行时间越写越短，内心有一点无比自豪的感觉，很喜欢这种超越自己的，继续加油吧。哈哈哈哈哈哈\n","slug":"7整数反转","date":"2021-05-03T16:27:50.000Z","categories_index":"算法","tags_index":"算法,Python","author_index":"阿朱"},{"id":"b529ed6ebbafadec850827aed7fed9b6","title":"两数之和 leetCode 1","content":"题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案\n\n\n示例 1：\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2：\n输入：nums = [3,2,4], target = 6输出：[1,2]示例 3：\n输入：nums = [3,3], target = 6输出：[0,1]\n解法1  Hash表解法思路：1、hash表存入的数据key:nums , value :对应下标使用目标值target减去数组中的每一个数，如果得到的值，不在hash表中，继续循环，如果存在，那说明是要找的数，直接返回两个下标。\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_table = dict()\n        for i,num in enumerate(nums):\n            if target - num in hash_table:\n                return [hash_table[target - num], i]\n            hash_table[num] = i\n\n\n\n","slug":"两数之和","date":"2021-05-03T11:55:20.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"5234a8c4e062136329f4963c94cde8ba","title":"砖墙问题 leetCode 554","content":"题目：你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。\n你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。\n给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 \n\n输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]输出：2示例 2：\n输入：wall = [[1],[1],[1]]输出：3\n\n\n1、题目分析\n题目要求穿过的砖块数量最少，等效于通过他的间隙最多\n将所有行总数，减去间隙，就是穿过最少的砖块数\n记住，每行的间隙位置，就是砖的左侧宽度和\n\n\n\n第 1 行的间隙有 [1,3,5]\n第 2 行的间隙有 [3,4]\n第 3 行的间隙有 [1,4]\n第 4 行的间隙有 [2]\n第 5 行的间隙有 [3,4]\n第 6 行的间隙有 [1,4,5]\n\n\n上述的每行的每个值，代表间隙位置，单行的间隙位置不会相同出\n统计间隙数，最后用总行数减去出现次数，即得到【最少穿过砖块数】\n\n解法1：使用hash表  52msclass Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        hashtable = dict()\n        for w in wall:\n            # 记录每一块砖缝，出现次数\n            ans = 0   # 每一行墙，墙缝 \n            # 最后一块砖的墙缝不算, [:-1]代表只取到倒数每二个数\n            for num in w[:-1]:\n                # 统计墙缝\n                ans += num\n                hashtable[ans] = hashtable.get(ans, 0) + 1\n        # 判断，所有行只有一块砖，就直接穿过所有\n        if not hashtable:\n            return len(wall)\n        return len(wall) - max(hashtable.values())\n    \n\n\n```\n","slug":"砖墙问题","date":"2021-05-03T06:22:29.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"901b553f2ebc4e976cd70013f9320085","title":"vim操作宝典","content":"在行尾插入视图模式：a 键\n\nVim显示文件已经打开非正常退出，就会产生.swp文件，可以把他删除\nrm -rf .文件名.swp\t\t\n\n复制多行数字键加yy\n例：复制4行\n4yy\n在行上方或者下方插入两个都是字母\no：在下方\nO：在上方\n\n合并两行视图模式：J\n\n多行注释（1）首先按键盘上的ESC进入命令行模式\n（2）再按Ctrl+V进入VISUAL BLOCK模式\n（3）利用上下左右键调整需要注释多少行以及行的宽度\n（4）再按Shift+i或s进入插入模式\n（5）输入代表注释的符号，比如#\n（6）再次按ESC键，这时就可完成多行注释（可能需要等上一会，不要着急）\n\n\n去注释（1）:起始行号,结束行号s/^/注释符/g\n打开目录nt\n\n纵向分屏，复制当前窗口: vsp\n在当前窗口切换编辑文件: e 文件路径\n\n粘贴历史行\"3p  （中间数字1到9）","slug":"vim操作宝典","date":"2021-05-01T12:41:12.000Z","categories_index":"Vim","tags_index":"Linux,Vim","author_index":"阿朱"},{"id":"83638110e00c80fbf85ca941956c7a6d","title":"linux操作宝典","content":"按内容搜索所有文件grep -rn &quot;hello,world!&quot; *\n\n* 表示当前目录所有文件，也可以是某个文件名\n-r 是递归查找\n-n 是显示行号\n-R 查找所有文件包含子目录\n-i 忽略大小写\n-l 只列出匹配的文件名\n-L 列出不匹配的文件名\n-w 只匹配整个单词，而不是字符串的一部分（匹配 hello，不匹配helloo）\n\n排查内存占用1.排查磁盘满的节点，执行以下命令：df -h\n\n2.进入df -h查出的异常分区，执行以下命令，逐层往下找出耗磁盘的目录。du -sh * | grep G\n\n3.进入消耗磁盘的目录，找出消耗磁盘空间的异常文件，执行命令：du -sh * | grep G 或者 du -sh * | grep T\n\n4.删除查找出来的异常文件命令：rm -rf 文件名\n\n5.如果上面找不出异常文件消耗磁盘空间，有可能是已删除文件但未释放内存，占用了很大的空间，执行命令：lsof -n | grep delete\n\n6.找出已删除的文件但未释放内存的进程，然后释放进程。kill -9 进程号","slug":"linux","date":"2021-04-29T06:33:15.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"阿朱"},{"id":"9a2252c0b559cb77f268bff5416cc06f","title":"shell脚本","content":"清屏clear\n输出换行，两个echo -e \"\\n\\n\"\n休息一秒sleep 1\n输出用户数who | awk '&#123;print $1&#125;' | sort | uniq | wc -l\n让计算机发出蜂鸣声echo -en \"\\007\"\n\n判断文件夹是否存在if [ ! -d \"./QQ/\" ];\nthen\n  mkdir QQ\nelse\n  echo \"文件夹存在\"\nfi\n文件目录追加到文件中ls >> 文件名\n\n输出白底黑字的文字echo -e \"\\033[47;30m Now at your service,*Zhu-Zhi-Wu* \\033[0m\"\n\n监听键盘输入任意键read -n 1 -p \"the End…\"\n\n\n\n输入三个数，输出最大数printf \"请输入三个书：\\n\"\nread first_num\nread secend_num\nread thd_num\nif [ $first_num -gt $secend_num ]\nthen\n  max=$first_num\nelse\n  max=$secend_num\nfi\n\nif [ $thd_num -gt $max ]\nthen\n  max=$thd_num\nfi\n\necho \"$max\"","slug":"shell脚本","date":"2021-04-25T03:42:36.000Z","categories_index":"Shell","tags_index":"Linux,Shell","author_index":"阿朱"}]
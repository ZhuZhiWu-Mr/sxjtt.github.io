[{"id":"b0332e478f2510b18d9d570091b0d2de","title":"整数反转 leetCode 7","content":"给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）\n1、解法1，未优化写法   40ms思路：\n展开我的思路\n   （1）这个题挺简单，就是通过%运算，每次都取到数的最后一位   （2）考虑到负数的问题，所以while那里使用了 x!=0，因为按这种方式计算，最后都会为0   （3）注意题目规定的整数范围，这里代码做了提前一位的判断。看下图解\n   \n   第二排数字中，橘子的是5，它是大于上面同位置的4，这就意味着5后跟任何数字，都会比最大32为整数都大。   所以，我们到【最大数的1/10】时，就要开始判断了   如果某个数字大于 214748364那后面就不用再判断了，肯定溢出了。   如果某个数字等于 214748364呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的末尾数字比较，如果这个数字比7还大，说明溢出了。\n负数也是一样：\n\n上图中绿色部分是最小的32位整数，同样是在【最小数的 1/10】时开始判断如果某个数字小于 -214748364说明溢出了如果某个数字等于 -214748364，还需要跟最小数的末尾比较，即看它是否小于8\n\n\n遇到问题：因为Python 的%运算，是使用的floor的方式，在计算负数的时候，会出现和Java不同，所以，都转成正数来取模运算\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        reverse_num = 0\n        # 2147483647\n        # -2147483648\n        while(x != 0):\n            if x &lt; 0:\n                tmp_num = -x % 10\n                tmp_num = -tmp_num\n            else:\n                tmp_num = x % 10\n            # 判断是否溢出\n            if (reverse_num > 214748364) or (reverse_num == 214748364 and tmp_num > 7):\n                return 0\n            if (reverse_num &lt; -214748364) or (reverse_num == 214748364 and tmp_num > 7):\n                return 0\n            reverse_num = reverse_num * 10 + tmp_num\n            x = int(x/10)\n        return reverse_num\n\n2、 将解法1所写的代码进行优化   32msclass Solution:\n    def reverse(self, x: int) -> int:\n        # 2147483647\n        # -2147483648\n        y, res = abs(x), 0\n        while(y != 0):\n            tmp_num = y % 10\n            # 判断是否溢出\n            if res &lt; -214748364:\n                return 0\n            if (res > 214748364) or (res == 214748364 and tmp_num > 7):\n                return 0\n            res = res * 10 + tmp_num\n            y = int(y/10)\n        return res if x > 0 else -res\n\n3、使用字符串反转的方法  36msclass Solution:\n    def reverse(self, x: int) -> int:\n        y = str(x)\n        ins = 1\n        res = \"\"\n        if y[0] == \"-\":\n            ins = -1\n            res = y[1:][::-1]\n        else:\n            res = y[::-1]\n        nums = int(res)\n        return 0 if nums &lt;-2**31 or nums > 2**31-1 else (ins * nums)\n\n题目总结：在用字符串反转的方法时，我发现Ptyhon这样将字符串进行转换，整型不会内存溢出，很好奇的我，去网上查阅了资料，发现Python3之后，都是统一使用了长整型\n\n现在是2021年5月4号零晨1:45分，这是我刷leetcode的第三道题，每次将自己写的一串很长的代码，优化成很简单，看着自己的代码运行时间越写越短，内心有一点无比自豪的感觉，很喜欢这种超越自己的，继续加油吧。哈哈哈哈哈哈\n","slug":"7整数反转","date":"2021-05-03T16:27:50.000Z","categories_index":"算法","tags_index":"算法,Python","author_index":"阿朱"},{"id":"b529ed6ebbafadec850827aed7fed9b6","title":"两数之和 leetCode 1","content":"题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案\n\n\n示例 1：\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2：\n输入：nums = [3,2,4], target = 6输出：[1,2]示例 3：\n输入：nums = [3,3], target = 6输出：[0,1]\n解法1  Hash表解法思路：1、hash表存入的数据key:nums , value :对应下标使用目标值target减去数组中的每一个数，如果得到的值，不在hash表中，继续循环，如果存在，那说明是要找的数，直接返回两个下标。\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_table = dict()\n        for i,num in enumerate(nums):\n            if target - num in hash_table:\n                return [hash_table[target - num], i]\n            hash_table[num] = i\n\n\n\n","slug":"两数之和","date":"2021-05-03T11:55:20.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"5234a8c4e062136329f4963c94cde8ba","title":"砖墙问题 leetCode 554","content":"题目：你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。\n你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。\n给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 \n\n输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]输出：2示例 2：\n输入：wall = [[1],[1],[1]]输出：3\n\n\n1、题目分析\n题目要求穿过的砖块数量最少，等效于通过他的间隙最多\n将所有行总数，减去间隙，就是穿过最少的砖块数\n记住，每行的间隙位置，就是砖的左侧宽度和\n\n\n\n第 1 行的间隙有 [1,3,5]\n第 2 行的间隙有 [3,4]\n第 3 行的间隙有 [1,4]\n第 4 行的间隙有 [2]\n第 5 行的间隙有 [3,4]\n第 6 行的间隙有 [1,4,5]\n\n\n上述的每行的每个值，代表间隙位置，单行的间隙位置不会相同出\n统计间隙数，最后用总行数减去出现次数，即得到【最少穿过砖块数】\n\n解法1：使用hash表  52msclass Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        hashtable = dict()\n        for w in wall:\n            # 记录每一块砖缝，出现次数\n            ans = 0   # 每一行墙，墙缝 \n            # 最后一块砖的墙缝不算, [:-1]代表只取到倒数每二个数\n            for num in w[:-1]:\n                # 统计墙缝\n                ans += num\n                hashtable[ans] = hashtable.get(ans, 0) + 1\n        # 判断，所有行只有一块砖，就直接穿过所有\n        if not hashtable:\n            return len(wall)\n        return len(wall) - max(hashtable.values())\n    \n\n\n```\n","slug":"砖墙问题","date":"2021-05-03T06:22:29.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"901b553f2ebc4e976cd70013f9320085","title":"vim操作宝典","content":"在行尾插入视图模式：a 键\n\nVim显示文件已经打开非正常退出，就会产生.swp文件，可以把他删除\nrm -rf .文件名.swp\t\t\n\n在行上方或者下方插入两个都是字母\no：在下方\nO：在上方\n\n合并两行视图模式：J\n\n多行注释（1）首先按键盘上的ESC进入命令行模式\n（2）再按Ctrl+V进入VISUAL BLOCK模式\n（3）利用上下左右键调整需要注释多少行以及行的宽度\n（4）再按Shift+i或s进入插入模式\n（5）输入代表注释的符号，比如#\n（6）再次按ESC键，这时就可完成多行注释（可能需要等上一会，不要着急）\n\n\n去注释（1）:起始行号,结束行号s&#x2F;^&#x2F;注释符&#x2F;g\n打开目录nt\n\n纵向分屏，复制当前窗口: vsp\n在当前窗口切换编辑文件: e 文件路径\n\n粘贴历史行&quot;3p  （中间数字1到9）","slug":"vim操作宝典","date":"2021-05-01T12:41:12.000Z","categories_index":"Vim","tags_index":"Linux,Vim","author_index":"阿朱"},{"id":"9a2252c0b559cb77f268bff5416cc06f","title":"shell脚本","content":"清屏clear\n输出换行，两个echo -e &quot;\\n\\n&quot;\n休息一秒sleep 1\n输出用户数who | awk &#39;&#123;print $1&#125;&#39; | sort | uniq | wc -l\n让计算机发出蜂鸣声echo -en &quot;\\007&quot;\n\n判断文件夹是否存在if [ ! -d &quot;.&#x2F;QQ&#x2F;&quot; ];\nthen\n  mkdir QQ\nelse\n  echo &quot;文件夹存在&quot;\nfi\n文件目录追加到文件中ls &gt;&gt; 文件名\n\n输出白底黑字的文字echo -e &quot;\\033[47;30m Now at your service,*Zhu-Zhi-Wu* \\033[0m&quot;\n\n监听键盘输入任意键read -n 1 -p &quot;the End…&quot;\n\n\n\n输入三个数，输出最大数printf &quot;请输入三个书：\\n&quot;\nread first_num\nread secend_num\nread thd_num\nif [ $first_num -gt $secend_num ]\nthen\n  max&#x3D;$first_num\nelse\n  max&#x3D;$secend_num\nfi\n\nif [ $thd_num -gt $max ]\nthen\n  max&#x3D;$thd_num\nfi\n\necho &quot;$max&quot;","slug":"shell脚本","date":"2021-04-25T03:42:36.000Z","categories_index":"Shell","tags_index":"Linux,Shell","author_index":"阿朱"},{"id":"83638110e00c80fbf85ca941956c7a6d","title":"linux操作宝典","content":"按内容搜索所有文件grep -rn &quot;hello,world!&quot; *\n\n* 表示当前目录所有文件，也可以是某个文件名\n-r 是递归查找\n-n 是显示行号\n-R 查找所有文件包含子目录\n-i 忽略大小写\n-l 只列出匹配的文件名\n-L 列出不匹配的文件名\n-w 只匹配整个单词，而不是字符串的一部分（匹配 hello，不匹配helloo）\n\n排查内存占用1.排查磁盘满的节点，执行以下命令：df -h\n\n2.进入df -h查出的异常分区，执行以下命令，逐层往下找出耗磁盘的目录。du -sh * | grep G\n\n3.进入消耗磁盘的目录，找出消耗磁盘空间的异常文件，执行命令：du -sh * | grep G 或者 du -sh * | grep T\n\n4.删除查找出来的异常文件命令：rm -rf 文件名\n\n5.如果上面找不出异常文件消耗磁盘空间，有可能是已删除文件但未释放内存，占用了很大的空间，执行命令：lsof -n | grep delete\n\n6.找出已删除的文件但未释放内存的进程，然后释放进程。kill -9 进程号","slug":"linux","date":"2021-04-24T06:33:15.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"阿朱"}]
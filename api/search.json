[{"id":"250c409a50fd09c16cdaf2126a453a8d","title":"两数之和 leetcode 1","content":"题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案\n\n\n示例 1：\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2：\n输入：nums = [3,2,4], target = 6输出：[1,2]示例 3：\n输入：nums = [3,3], target = 6输出：[0,1]\n解法1  Hash表解法思路：1、hash表存入的数据key:nums , value :对应下标使用目标值target减去数组中的每一个数，如果得到的值，不在hash表中，继续循环，如果存在，那说明是要找的数，直接返回两个下标。\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_table = dict()\n        for i,num in enumerate(nums):\n            if target - num in hash_table:\n                return [hash_table[target - num], i]\n            hash_table[num] = i\n\n\n\n","slug":"两数之和","date":"2021-05-03T11:55:20.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"91879f453d10785d92208d969ecf7341","title":"砖墙问题 leecode 554","content":"题目：你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。\n你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。\n给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 \n\n输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]输出：2示例 2：\n输入：wall = [[1],[1],[1]]输出：3\n\n\n1、题目分析\n题目要求穿过的砖块数量最少，等效于通过他的间隙最多\n将所有行总数，减去间隙，就是穿过最少的砖块数\n记住，每行的间隙位置，就是砖的左侧宽度和\n\n\n\n第 1 行的间隙有 [1,3,5]\n第 2 行的间隙有 [3,4]\n第 3 行的间隙有 [1,4]\n第 4 行的间隙有 [2]\n第 5 行的间隙有 [3,4]\n第 6 行的间隙有 [1,4,5]\n\n\n上述的每行的每个值，代表间隙位置，单行的间隙位置不会相同出\n统计间隙数，最后用总行数减去出现次数，即得到【最少穿过砖块数】\n\n解法1：使用hash表  52msclass Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        hashtable = dict()\n        for w in wall:\n            # 记录每一块砖缝，出现次数\n            ans = 0   # 每一行墙，墙缝 \n            for num in w[:-1]:\n                # 统计墙缝\n                ans += num\n                hashtable[ans] = hashtable.get(ans, 0) + 1\n        if not hashtable:\n            return len(wall)\n        return len(wall) - max(hashtable.values())","slug":"砖墙问题","date":"2021-05-03T06:22:29.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"83638110e00c80fbf85ca941956c7a6d","title":"linux操作宝典","content":"按内容搜索所有文件grep -rn &quot;hello,world!&quot; *\n\n\n: 表示当前目录所有文件，也可以是某个文件名\n\n-r 是递归查找-n 是显示行号-R 查找所有文件包含子目录-i 忽略大小写-l 只列出匹配的文件名-L 列出不匹配的文件名-w 只匹配整个单词，而不是字符串的一部分（匹配 hello，不匹配helloo）\n排查内存占用1.排查磁盘满的节点，执行以下命令：df -h\n\n2.进入df -h查出的异常分区，执行以下命令，逐层往下找出耗磁盘的目录。du -sh * | grep G\n\n3.进入消耗磁盘的目录，找出消耗磁盘空间的异常文件，执行命令：du -sh * | grep G 或者 du -sh * | grep T\n\n4.删除查找出来的异常文件命令：rm -rf 文件名\n\n5.如果上面找不出异常文件消耗磁盘空间，有可能是已删除文件但未释放内存，占用了很大的空间，执行命令：lsof -n | grep delete\n\n6.找出已删除的文件但未释放内存的进程，然后释放进程。kill -9 进程号","slug":"linux","date":"2021-04-03T06:33:15.000Z","categories_index":"linux","tags_index":"linux","author_index":"阿朱"}]
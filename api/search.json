[{"id":"378da439daa2ee05d165c8ebd4326ea7","title":"1734解码异或的排列","content":"给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。示例 1：输入：encoded = [3,1]输出：[1,2,3]解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]\n示例 2：输入：encoded = [6,5,4,6]输出：[2,4,1,5,3]\n此题是leetcode 1720的升级版\n一、解法一：通过数据解题思路（异或运算）1.1 思路我在LeetCode上面看题解的时候，看得好吃力，完全没看懂，然后跟着思路用纸写一遍，突然就懂了。话不多说，开始：\n我们知道异或运算有如下性质（不懂的话，可以查一下，不多做解释了）：\n\n相同数值异或，结果为 0\n任意数值与 0 进行异或，结果为数值本身\n异或本身满足交换律\n\n⊕：代表异或\n本题需要我们求perm（需求一步一步往下看，不然会不懂）\n\n根据题目意思 ，假设 perm = [a, b, c, d, e]，那么 encoded = [ab, bc, cd, de]\n\n先求出perm[0]  ,    perm[0] =   (perm[0] ⊕ perm[1] … ⊕ perm[n] )  ⊕    (perm[1] …⊕ perm[n] )   ,根据相同值异或为0性质，异或结果就是perm[0]，看懂了再往下走\n\n此时我们只需要求出**(perm[0] ⊕ perm[1] … ⊕ perm[n] )** 和**(perm[1] …⊕ perm[n] )的值，他俩异或的结果就可以求出perm[0]**\n\n\n求第2步的两个值：\n\n(perm[0] ⊕ perm[1] … ⊕ perm[n] )，题目已经告诉我们的，他是前 n 个正整数的排列，假如n=5 ,他结果就是1⊕ 2⊕ 3⊕ 4⊕ 5,\n(perm[1] …⊕ perm[n] ),这个值看如下举例：\n\n假设 perm = [a, b, c, d, e]，那么 encoded = [ab, bc, cd, de]\nperm[1] ⊕ perm[2] …⊕ perm[n]  =  encoded[1] ⊕ encoded[3]   (步长为2)\n\nencoded都是题目给出来的值 ，是不是很好求\n这样你就可以结合第二步，求出**perm[0]**的值\n\n\n题目给出encoded[i] = perm[i] ⊕ perm[i + 1]    可以理解为：encoded[i] = perm[i] ⊕ perm[i - 1]    一样的意思， 只是我把下标 i理解为当前这个数和当前数的前一个\n\n​    encoded[0] = perm[0] ⊕ perm[1]  两边同时异或 perm[1],  根据相同为0，得出如下\n​    perm[1] = encoded[0] ⊕ perm[0]\n​    perm[i] = encoded[i] ⊕ perm[i - 1]\n\n\n\n最后再去看代码，就很清晰了，总结的不好的，欢迎留言指正；\nclass Solution:\n    def decode(self, encoded: List[int]) -> List[int]:\n        n = len(encoded) + 1\n        \n        perm_total = reduce(xor, range(1, len(encoded) + 2))\n        \n        child_total = 0\n        for i in range(1, len(encoded), 2):\n            child_total ^= encoded[i]\n           \n        perm = [perm_total ^ child_total]\n        \n        for j in range(1, len(encoded) + 1):\n            perm.append(encoded[j - 1] ^ perm[j - 1])\n        return perm\n\n\n\n\n\n","slug":"1734解码异或的排列","date":"2021-05-12T04:29:27.000Z","categories_index":"算法","tags_index":"算法,Python,异或","author_index":"阿朱"},{"id":"d4cfe049c5b6be882045489e2054f761","title":"TCP和UDP协议","content":"TCP的三次握手和四次挥手","slug":"TCP和UDP协议","date":"2021-05-10T07:43:32.000Z","categories_index":"网络","tags_index":"TCP,UDP","author_index":"阿朱"},{"id":"fdf447c09b614244b1d615663633680c","title":"169多数元素","content":"给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n一、解法一 使用消除法此解法扣重点：出现次数会大于【n/2】的元素\n（1）从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个，以一换一去换，最多的那一队，怎么都会多1个。\n使用举例：\n​        现在去打战，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利，其他国家的人相互攻击，只要不打内战，只有赢家能扛到最后，可以通过这个思路先自己写一遍代码，写不出，可以参考以下，如有不好的地方，可以评论留言。\ndef majorityElement(self, nums: List[int]) -> int:\n    count = 0\n    re_nu = -1\n    for num in nums:\n        if num == re_nu:\n            count += 1\n        else:\n            if count == 0:\n                re_nu = num\n                continue\n            count -= 1\n    return re_nu\n\n\n\n\n二、解法二 使用Hash这就不多做解释了，看代码吧\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        hashtable = dict()\n        for num in nums:\n            if num in hashtable:\n                hashtable[num] = hashtable[num] + 1\n            else:\n                hashtable[num] = 1\n        # 获取dict value最大的key值。\n        return max(hashtable, key=hashtable.get)\n\n","slug":"169多数元素","date":"2021-05-06T13:19:52.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"35c279d773f512ff2cf029127b15b0e0","title":"136只出现一次的数字 LeetCode","content":"题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n说明：\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n示例 1:\n输入: [2,2,1]输出: 1示例 2:\n输入: [4,1,2,1,2]输出: 4\n主要学习解法2\n一、解法1，使用set()set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等\n代码比较简单，不做过多的解释，看看就懂。\ndef singleNumber(self, nums: List[int]) -> int:\n    num_set = set()\n    for num in nums:\n        if num in num_set:\n            num_set.remove(num)\n        else:\n            num_set.add(num)\n    return list(num_set)[0]\n\n\n\n\n二、解法2，使用异或运算⊕: 异或符号\n答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。\n\n任何数和 0 做异或运算，结果仍然是原来的数，即 a ⊕ 0=a\n\n任何数和其自身做异或运算，结果是 0，即 a  ⊕ a=0\n\n异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b（简单来说，就是不管异或的顺序如何，最终结果都是一样的，本解法，关键就是利用这一点）\n\n\n  交换律和结合律详解    比如:\na=1,b=2,c=2,d=4,e=4\na ^ d ^ c ^ b ^ e == b ^ c ^ d ^ e ^ a  == 1\t\n# 不管顺序如何,如果都是一样,结果都是一样\n\n博主思考：\n\n写完这个题的时候,我就在床上思考, 如果a⊕a = 0,那么a⊕a⊕a呢,那他就不是0了,怎么可以求得解呢?\n\n答:就在这时,我去重新看了一眼题目,题目表明了,每个数都只出现两次,只有一个数出现了一次,审题得仔细.\n也可以把这个思考当做一个新题目去做,在一堆不确定出现次数的数中,找出只出现了一次的数,又或者是在一堆数字中,找出现次数最少的数字\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        re_num = 0\n        for num in nums:\n            re_num = num ^ re_num\n        return re_num\n\n\n\n\n\n","slug":"136只出现一次的数字","date":"2021-05-05T12:27:25.000Z","categories_index":"算法","tags_index":"算法,Python,异或","author_index":"阿朱"},{"id":"be827bd3744cf66f970afc1974c2f8ba","title":"237删除链表中的节点 leetCode","content":"题目：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。这个题一开始，我也有点懞，被这个题目弄傻了。后面看了下题解，豁然开朗。\n主要思路\n\n将下一个节点的值赋值给当前节点\n\n然后把下一个节点删除即可（删除方法：将当前节点next指向下一个节点的next）\n\n\nclass Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next","slug":"237删除链表中的节点","date":"2021-05-05T12:03:58.000Z","categories_index":"算法","tags_index":"算法,Python,链表","author_index":"阿朱"},{"id":"9319bb79084ec16cc2b86c7f0a8d2c6a","title":"Django","content":"Django程序开机自动启动\n通过shell脚本，设置开机自动启动Django的uwsgi服务（测试环境Cento8）\n1、切换到/etc/init.d/，目录下创建一个自己的脚本2、制作sh脚本 vim start_uwsgi注意，注释也要加进去\n#!/bin/sh\n#add for chkconfig\n#chkconfig: 2345 70 30\n#description: the description of the shell   #关于脚本的简短描述\n#processname: andyStart      #第一个进程名，后边设置自启动的时候会用到\n#下面要启动服务的命令\nsource /418pro/env/djangoVenv/bin/activate &amp;&amp; uwsgi --ini /418pro/uwsgi-configs/django.ini   #进入虚拟环境 &amp;&amp; 启动uwsgi 配置文件的具体位置\n\n说明：\n（1）2345是指脚本的运行级别，即在2345这4种模式下都可以运行，234都是文本界面，5就是图形界面X\n（1）70是指脚本将来的启动顺序号，如果别的程序的启动顺序号比70小（比如44、45），则脚本需要等这些程序都启动以后才启动。\n（1）30是指系统关闭时，脚本的停止顺序号。\nlinux 下shell脚本执行多个命令的方法\n(1)每个命令之间用;隔开\n说明：各命令的执行给果，不会影响其它命令的执行。换句话说，各个命令都会执行，但不保证每个命令都执行成功。\n(2)每个命令之间用&amp;&amp;隔开\n说明：若前面的命令执行成功，才会去执行后面的命令。这样可以保证所有的命令执行完毕后，执行过程都是成功的。\n(3)每个命令之间用||隔开\n说明：||是或的意思，只有前面的命令执行失败后才去执行下一条命令，直到执行成功一条命令为止。\n3、给脚本加上可执行权限：chmod a+x start_uwsgi\n\n\n4、利用chkconfig命令将脚本设置为自启动：chkconfig --add start_uwsgi\n\n\n","slug":"Django","date":"2021-05-05T06:39:18.000Z","categories_index":"Django","tags_index":"Python,Django","author_index":"阿朱"},{"id":"5657dbaafc65d44bb7226a49ee6df3c8","title":"nginx","content":"设置开机自动启动\nnginx开机自动启动(Centos8测试环境)\n1、init.d下创建文件nginxvim /etc/init.d/nginx\nnginx官方文档\n2、将官方配置，添加到编辑的文件中：nginx=”/usr/local/nginx/sbin/nginx” //修改成nginx执行程序的路径。\nNGINX_CONF_FILE=”/usr/local/nginx/conf/nginx.conf” //修改成nginx.conf文\n件的路径。\n3、保存后设置文件的执行权限chmod a+x /etc/init.d/nginx\n\n4、通过下面指令控制启动停止/etc/init.d/nginx start\n/etc/init.d/nginx stop\n查看进程命令\nps aux | grep nginx\n也可以通过kill掉pid来关闭进程\n5、上面测试通过后、将nginx服务加入chkconfig管理列表：chkconfig --add /etc/init.d/nginx\n\n6、加完5之后，可以使用service对nginx进行启动，重启等操作。service nginx start\nservice nginx stop\nservice nginx restart\n7、最后设置开机自动启动chkconfig nginx on\n\n\n","slug":"nginx","date":"2021-05-05T04:39:04.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"阿朱"},{"id":"b0332e478f2510b18d9d570091b0d2de","title":"整数反转 leetCode 7","content":"给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）\n1、解法1，未优化写法   40ms思路：\n展开我的思路\n   （1）这个题挺简单，就是通过%运算，每次都取到数的最后一位   （2）考虑到负数的问题，所以while那里使用了 x!=0，因为按这种方式计算，最后都会为0   （3）注意题目规定的整数范围，这里代码做了提前一位的判断。看下图解\n   \n   第二排数字中，橘子的是5，它是大于上面同位置的4，这就意味着5后跟任何数字，都会比最大32为整数都大。   所以，我们到【最大数的1/10】时，就要开始判断了   如果某个数字大于 214748364那后面就不用再判断了，肯定溢出了。   如果某个数字等于 214748364呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的末尾数字比较，如果这个数字比7还大，说明溢出了。\n负数也是一样：\n\n上图中绿色部分是最小的32位整数，同样是在【最小数的 1/10】时开始判断如果某个数字小于 -214748364说明溢出了如果某个数字等于 -214748364，还需要跟最小数的末尾比较，即看它是否小于8\n\n\n遇到问题：因为Python 的%运算，是使用的floor的方式，在计算负数的时候，会出现和Java不同，所以，都转成正数来取模运算\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        reverse_num = 0\n        # 2147483647\n        # -2147483648\n        while(x != 0):\n            if x &lt; 0:\n                tmp_num = -x % 10\n                tmp_num = -tmp_num\n            else:\n                tmp_num = x % 10\n            # 判断是否溢出\n            if (reverse_num > 214748364) or (reverse_num == 214748364 and tmp_num > 7):\n                return 0\n            if (reverse_num &lt; -214748364) or (reverse_num == 214748364 and tmp_num > 7):\n                return 0\n            reverse_num = reverse_num * 10 + tmp_num\n            x = int(x/10)\n        return reverse_num\n\n2、 将解法1所写的代码进行优化   32msclass Solution:\n    def reverse(self, x: int) -> int:\n        # 2147483647\n        # -2147483648\n        y, res = abs(x), 0\n        while(y != 0):\n            tmp_num = y % 10\n            # 判断是否溢出\n            if res &lt; -214748364:\n                return 0\n            if (res > 214748364) or (res == 214748364 and tmp_num > 7):\n                return 0\n            res = res * 10 + tmp_num\n            y = int(y/10)\n        return res if x > 0 else -res\n\n3、使用字符串反转的方法  36msclass Solution:\n    def reverse(self, x: int) -> int:\n        y = str(x)\n        ins = 1\n        res = \"\"\n        if y[0] == \"-\":\n            ins = -1\n            res = y[1:][::-1]\n        else:\n            res = y[::-1]\n        nums = int(res)\n        return 0 if nums &lt;-2**31 or nums > 2**31-1 else (ins * nums)\n\n题目总结：在用字符串反转的方法时，我发现Ptyhon这样将字符串进行转换，整型不会内存溢出，很好奇的我，去网上查阅了资料，发现Python3之后，都是统一使用了长整型\n\n现在是2021年5月4号零晨1:45分，这是我刷leetcode的第三道题，每次将自己写的一串很长的代码，优化成很简单，看着自己的代码运行时间越写越短，内心有一点无比自豪的感觉，很喜欢这种超越自己的，继续加油吧。哈哈哈哈哈哈\n","slug":"7整数反转","date":"2021-05-03T16:27:50.000Z","categories_index":"算法","tags_index":"算法,Python","author_index":"阿朱"},{"id":"b529ed6ebbafadec850827aed7fed9b6","title":"两数之和 leetCode 1","content":"题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案\n\n\n示例 1：\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2：\n输入：nums = [3,2,4], target = 6输出：[1,2]示例 3：\n输入：nums = [3,3], target = 6输出：[0,1]\n解法1  Hash表解法思路：1、hash表存入的数据key:nums , value :对应下标使用目标值target减去数组中的每一个数，如果得到的值，不在hash表中，继续循环，如果存在，那说明是要找的数，直接返回两个下标。\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash_table = dict()\n        for i,num in enumerate(nums):\n            if target - num in hash_table:\n                return [hash_table[target - num], i]\n            hash_table[num] = i\n\n\n\n","slug":"两数之和","date":"2021-05-03T11:55:20.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"5234a8c4e062136329f4963c94cde8ba","title":"砖墙问题 leetCode 554","content":"题目：你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。\n你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。\n给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 \n\n输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]输出：2示例 2：\n输入：wall = [[1],[1],[1]]输出：3\n\n\n1、题目分析\n题目要求穿过的砖块数量最少，等效于通过他的间隙最多\n将所有行总数，减去间隙，就是穿过最少的砖块数\n记住，每行的间隙位置，就是砖的左侧宽度和\n\n\n\n第 1 行的间隙有 [1,3,5]\n第 2 行的间隙有 [3,4]\n第 3 行的间隙有 [1,4]\n第 4 行的间隙有 [2]\n第 5 行的间隙有 [3,4]\n第 6 行的间隙有 [1,4,5]\n\n\n上述的每行的每个值，代表间隙位置，单行的间隙位置不会相同出\n统计间隙数，最后用总行数减去出现次数，即得到【最少穿过砖块数】\n\n解法1：使用hash表  52msclass Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        hashtable = dict()\n        for w in wall:\n            # 记录每一块砖缝，出现次数\n            ans = 0   # 每一行墙，墙缝 \n            # 最后一块砖的墙缝不算, [:-1]代表只取到倒数每二个数\n            for num in w[:-1]:\n                # 统计墙缝\n                ans += num\n                hashtable[ans] = hashtable.get(ans, 0) + 1\n        # 判断，所有行只有一块砖，就直接穿过所有\n        if not hashtable:\n            return len(wall)\n        return len(wall) - max(hashtable.values())\n    \n\n\n```\n","slug":"砖墙问题","date":"2021-05-03T06:22:29.000Z","categories_index":"算法","tags_index":"算法,Python,Hash","author_index":"阿朱"},{"id":"901b553f2ebc4e976cd70013f9320085","title":"vim操作宝典","content":"在行尾插入视图模式：a 键\n\nVim显示文件已经打开非正常退出，就会产生.swp文件，可以把他删除\nrm -rf .文件名.swp\t\t\n\n复制多行数字键加yy\n例：复制4行\n4yy\n在行上方或者下方插入两个都是字母\no：在下方\nO：在上方\n\n合并两行视图模式：J\n\n多行注释（1）首先按键盘上的ESC进入命令行模式\n（2）再按Ctrl+V进入VISUAL BLOCK模式\n（3）利用上下左右键调整需要注释多少行以及行的宽度\n（4）再按Shift+i或s进入插入模式\n（5）输入代表注释的符号，比如#\n（6）再次按ESC键，这时就可完成多行注释（可能需要等上一会，不要着急）\n\n\n去注释（1）:起始行号,结束行号s/^/注释符/g\n打开目录nt\n\n纵向分屏，复制当前窗口: vsp\n在当前窗口切换编辑文件: e 文件路径\n\n粘贴历史行\"3p  （中间数字1到9）","slug":"vim操作宝典","date":"2021-05-01T12:41:12.000Z","categories_index":"Vim","tags_index":"Linux,Vim","author_index":"阿朱"},{"id":"83638110e00c80fbf85ca941956c7a6d","title":"linux操作宝典","content":"按内容搜索所有文件grep -rn &quot;hello,world!&quot; *\n\n* 表示当前目录所有文件，也可以是某个文件名\n-r 是递归查找\n-n 是显示行号\n-R 查找所有文件包含子目录\n-i 忽略大小写\n-l 只列出匹配的文件名\n-L 列出不匹配的文件名\n-w 只匹配整个单词，而不是字符串的一部分（匹配 hello，不匹配helloo）\n\n排查内存占用1.排查磁盘满的节点，执行以下命令：df -h\n\n2.进入df -h查出的异常分区，执行以下命令，逐层往下找出耗磁盘的目录。du -sh * | grep G\n\n3.进入消耗磁盘的目录，找出消耗磁盘空间的异常文件，执行命令：du -sh * | grep G 或者 du -sh * | grep T\n\n4.删除查找出来的异常文件命令：rm -rf 文件名\n\n5.如果上面找不出异常文件消耗磁盘空间，有可能是已删除文件但未释放内存，占用了很大的空间，执行命令：lsof -n | grep delete\n\n6.找出已删除的文件但未释放内存的进程，然后释放进程。kill -9 进程号","slug":"linux","date":"2021-04-29T06:33:15.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"阿朱"},{"id":"9a2252c0b559cb77f268bff5416cc06f","title":"shell脚本","content":"清屏clear\n输出换行，两个echo -e \"\\n\\n\"\n休息一秒sleep 1\n输出用户数who | awk '&#123;print $1&#125;' | sort | uniq | wc -l\n让计算机发出蜂鸣声echo -en \"\\007\"\n\n判断文件夹是否存在if [ ! -d \"./QQ/\" ];\nthen\n  mkdir QQ\nelse\n  echo \"文件夹存在\"\nfi\n文件目录追加到文件中ls >> 文件名\n\n输出白底黑字的文字echo -e \"\\033[47;30m Now at your service,*Zhu-Zhi-Wu* \\033[0m\"\n\n监听键盘输入任意键read -n 1 -p \"the End…\"\n\n\n\n输入三个数，输出最大数printf \"请输入三个书：\\n\"\nread first_num\nread secend_num\nread thd_num\nif [ $first_num -gt $secend_num ]\nthen\n  max=$first_num\nelse\n  max=$secend_num\nfi\n\nif [ $thd_num -gt $max ]\nthen\n  max=$thd_num\nfi\n\necho \"$max\"","slug":"shell脚本","date":"2021-04-25T03:42:36.000Z","categories_index":"Shell","tags_index":"Linux,Shell","author_index":"阿朱"}]